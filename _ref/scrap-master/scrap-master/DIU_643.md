# DIU PROJ00643: Autonomous Vehicle Orchestrator
## Technical Proposal: SCRAP Secure Command Authorization Layer

**Solicitation:** PROJ00643 - Autonomous Vehicle Orchestrator
**Submission Date:** January 2026
**Offeror:** DysonLabs

---

## Executive Summary

DysonLabs proposes **SCRAP** (Secure Command Routing and Authorization Protocol) and **SISL** (Secure Inter-System Link) as the back-end authorization and communications layer for the DIU Autonomous Vehicle Orchestrator. SCRAP handles cryptographic command authorization using capability tokens that vehicles verify offline, without connectivity to ground stations. SISL provides secure link establishment between vehicles using only pre-shared public keys--no symmetric key fill required--with per-session forward secrecy and LPI/LPD properties.

Together, the protocols deliver:

- **Offline authorization** - Capability tokens are self-contained proofs; no policy server needed
- **Resilient routing** - Hedged multipath with millisecond failover when nodes are lost
- **Ad-hoc mesh** - Vehicles establish secure links on contact via mutual-auth DH
- **Contested environment resilience** - Per-session spreading codes provide LPI/LPD

**Teaming:** DysonLabs provides the secure back-end. We seek a partner for the LLM-based front-end (intent parsing, voice/text/GUI).

---

## 1. Technical Approach

### 1.1 Architecture Overview

```
+-------------------------------------------------------------------------+
|                    ORCHESTRATOR ARCHITECTURE                            |
+-------------------------------------------------------------------------+
|                                                                         |
|  FRONT-END (Partner)                                                    |
|  +--------------------------------------------------------------------+ |
|  |  Voice/Text/GUI -> LLM Intent Parser -> Structured Commands        | |
|  +--------------------------------------------------------------------+ |
|                              |                                          |
|                              v                                          |
|  BACK-END (DysonLabs SCRAP)                                             |
|  +--------------------------------------------------------------------+ |
|  |  Authorization   |  Constraint       |  Resilient    |  Secure     | |
|  |  (Cap Tokens)    |  Enforcement      |  Routing      |  Transport  | |
|  +--------------------------------------------------------------------+ |
|                              |                                          |
|                              v                                          |
|  TRANSPORT LAYER                                                        |
|  +--------------------------------------------------------------------+ |
|  |  SISL (novel)    |  GFE Tactical Radios  |  IP/SATCOM              | |
|  +--------------------------------------------------------------------+ |
|                                                                         |
+-------------------------------------------------------------------------+
```

### 1.2 Component Summary

| Component | Function | Novel Contribution |
|-----------|----------|-------------------|
| **Capability Tokens** | Cryptographic command authorization | Offline verification, delegation |
| **Hedged Routing** | Resilient command delivery | Pre-computed multipath with cascading fallback |
| **SISL** | Secure link establishment | Per-session keys, no symmetric key fill, LPI/LPD |

---

## 2. Cryptographic Command Authorization

### 2.1 Capability Token Model

Commands are authorized by **capability tokens** and bound to specific command content via signature:

```
+------------------------------------------------------------------------+
|                      AUTHORIZED COMMAND STRUCTURE                      |
+------------------------------------------------------------------------+
|  CAPABILITY TOKEN (long-lived, reusable):                              |
|    issuer:        Commander's public key                               |
|    subject:       Operator's public key                                |
|    audience:      Target vehicle(s)                                    |
|    validity:      3600 seconds (relative window)                       |
|    token_id:      Unique identifier                                    |
|    capabilities:  [cmd:formation:*, cmd:movement:transit]              |
|    constraints:   {geo: <polygon>, rate: 10/hour}                      |
|    delegation:    {allowed: true, members: [...]} (optional)           |
|    token_sig:     ECDSA-P384 by issuer over above fields               |
|                                                                        |
|  COMMAND ENVELOPE (per-command):                                       |
|    token_hash:    SHA-384 hash of capability token                     |
|    command:       {type: "formation", params: {...}}                   |
|    seq:           Monotonic sequence number (replay protection)        |
|    command_sig:   ECDSA-P384 by subject over (token_hash || command    |
|                   || seq)                                              |
+------------------------------------------------------------------------+

Vehicle verification:
  1. Verify token_sig by issuer (is token valid?)
  2. Verify command_sig by subject (did authorized operator send this?)
  3. Check command.type against capabilities (is action permitted?)
  4. Check seq > last_seen_seq for this subject (replay protection)
  5. Check constraints (geo bounds, rate limit)
```

The separation allows tokens to be issued in advance and reused for multiple commands within the validity window. The command signature binds token to specific command content, preventing token reuse with unauthorized commands.

### 2.2 Authorization Properties

| Property | Mechanism | Benefit |
|----------|-----------|---------|
| **Authentication** | ECDSA signatures (P-384) | Verify command origin |
| **Authorization** | Explicit capability list | Only permitted operations execute |
| **Constraints** | Embedded bounds | Geographic, temporal, rate limits enforced at edge |
| **Delegation** | Signed sub-tokens | Subordinates receive attenuated authority |
| **Audit** | Non-repudiable signatures | Complete command history |
| **Offline** | Self-contained proof | No policy server connectivity required |

### 2.3 Delegation for Formation Commands

Formation commands require coordinated action across multiple vehicles. Rather than C&C sending N individual commands, SCRAP delegates authority to the formation leader:

**Setup (once per formation):**
```
C&C distributes delegation token to all formation members:
  {
    issuer:      commander
    subject:     V1 (leader)
    audience:    [V1, V2, V3, V4, V5]
    capabilities: [cmd:formation:*]
    delegation:  {allowed: true, depth: 1}
    token_sig:   commander_sig
  }

All members cache this token locally.
```

**Command flow:**
```
1. C&C sends formation command to V1:
   Command: {type: "echelon_left", params: {...}}
   Token:   (references cached delegation token)

2. V1 computes member-specific waypoints based on local geometry

3. V1 issues sub-commands to each member:
   {
     parent_token_hash: SHA-384(delegation_token)
     command:           {type: "waypoint", x, y, z}
     seq:               monotonic
     issuer:            V1
     audience:          V2
     command_sig:       V1_sig
   }

4. V2 verifies:
   - V2 has cached delegation token matching parent_token_hash
   - Delegation token lists V1 as subject with delegation.allowed
   - V2 is in delegation token's audience
   - command_sig valid from V1
   - "waypoint" is subset of "formation:*" capability
```

**Capability subsetting:** Capabilities form a hierarchy. `cmd:formation:*` permits any formation-related action including `cmd:movement:waypoint` (vehicles must move to form up). The capability lattice is defined in the protocol spec.

Benefits:
- C&C sends one command, not N
- Members already have delegation token; no per-command overhead
- Leader adapts to local conditions
- Cryptographic chain verifiable offline

---

## 3. SISL: Secure Inter-System Link Protocol

### 3.1 Overview

SISL is a **link-layer security protocol** enabling secure communication between vehicles that have never previously communicated, using only pre-shared identity public keys. It eliminates symmetric key distribution logistics while providing per-session forward secrecy and low probability of intercept/detection.

SISL sessions are **bidirectional**. Once a session is established (for command delivery, telemetry, or coordination), data flows securely in both directions on the same session-derived spreading code. This enables:
- Commands flowing from C&C to vehicles
- Telemetry, status, and sensor data flowing from vehicles to C&C
- Vehicle-to-vehicle coordination (formation members sharing position data)

### 3.2 Key Innovation: No Symmetric Key Fill

**Current military approach:**
```
Before deployment:
  1. Generate symmetric keys at secure facility
  2. Load keys onto fill device (SKL)
  3. Physically transport fill device to unit
  4. Load keys into each radio
  5. Coordinate timing across all radios

Problems:
  - Logistics burden (physical key transport)
  - Key compromise exposes entire net
  - Cross-domain coordination requires shared keys
  - No forward secrecy (same key used repeatedly)
```

**SISL approach:**
```
Before deployment:
  1. Generate identity key pair per vehicle
  2. Distribute public keys (trust list) via any channel

At contact:
  1. Vehicles perform mutual-auth DH key agreement
  2. Session keys derived from ephemeral exchange
  3. Ephemeral keys deleted after session

Benefits:
  - No symmetric key transport
  - Session compromise doesn't expose other sessions
  - Cross-domain requires only public key exchange
  - Forward secrecy built-in
```

### 3.3 Key Agreement

SISL uses a mutually-authenticated ephemeral DH protocol (similar to Noise IK) with NIST P-384:

```
+------------------------------------------------------------------------+
|                    KEY AGREEMENT (P-384)                               |
+------------------------------------------------------------------------+
|                                                                        |
|  Vehicle A (initiator)              Vehicle B (responder)              |
|  Static key: (a, A)                 Static key: (b, B)                 |
|  Ephemeral: (ea, EA)                Ephemeral: (eb, EB)                |
|                                                                        |
|         EA, A                                                          |
|  ---------------------------------------------------------->           |
|                                                                        |
|         EB                                                             |
|  <----------------------------------------------------------           |
|                                                                        |
|  Both compute three DH values:                                         |
|    DH1 = ECDH(ea, B)    --- Authenticates B                            |
|    DH2 = ECDH(a, EB)    --- Authenticates A                            |
|    DH3 = ECDH(ea, EB)   --- Forward secrecy                            |
|                                                                        |
|  Key derivation (HKDF-SHA384):                                         |
|    salt   = 0x00...00 (32 bytes)                                       |
|    IKM    = DH1 || DH2 || DH3                                          |
|    info   = "SISL-v1" || A || B || EA || EB (identity + transcript)    |
|                                                                        |
|    master = HKDF-Extract(salt, IKM)                                    |
|    enc_key     = HKDF-Expand(master, "encrypt", 32)                    |
|    mac_key     = HKDF-Expand(master, "mac", 32)                        |
|    spread_seed = HKDF-Expand(master, "spreading", 32)                  |
|                                                                        |
+------------------------------------------------------------------------+
```

The `info` parameter binds the session to both identities and the ephemeral transcript, preventing unknown key-share and identity misbinding attacks.

### 3.4 Two-Phase Spreading Codes (LPI/LPD)

SISL provides Low Probability of Intercept/Detection through cryptographically-derived spreading codes:

```
+------------------------------------------------------------------------+
|                    TWO-PHASE SPREADING ARCHITECTURE                    |
+------------------------------------------------------------------------+
|                                                                        |
|  PHASE 1: HAILING (public code)                                        |
|  ================================                                      |
|    Spreading code: PUBLIC (known to all SISL vehicles)                 |
|    Content: ENCRYPTED to target's public key                           |
|                                                                        |
|    Any SISL vehicle can: Detect and receive hail                       |
|    Only target can: Decrypt content, learn caller identity             |
|    Adversary sees: Encrypted blob, cannot decrypt                      |
|                                                                        |
|    NOTE: Hailing is detectable. An adversary can observe that          |
|    session establishment is occurring, but cannot identify parties     |
|    or follow the subsequent session traffic.                           |
|                                                                        |
|  PHASE 2: SESSION (secret code)                                        |
|  ================================                                      |
|    Spreading code: HKDF-Expand(master, "spreading", 32)                |
|    Encryption: AES-256-GCM with enc_key                                |
|    Nonce: 12-byte counter, incremented per packet, never reused        |
|           (session terminates before 2^32 packets)                     |
|                                                                        |
|    Only session parties can: Even DETECT the signal                    |
|    Adversary sees: NOTHING (signal below noise floor)                  |
|                                                                        |
+------------------------------------------------------------------------+
```

**Why this matters for contested environments:**

| Threat | Traditional FHSS | SISL |
|--------|------------------|-----------|
| Intercept hopping pattern | Capture key -> intercept all traffic | Each session has unique code |
| Direction finding | Detectable during all transmissions | Session traffic undetectable |
| Traffic analysis | Can count transmissions | Cannot detect session exists |
| Key compromise scope | Entire net exposed | Single session exposed |

### 3.5 Ad-Hoc Mesh Formation

SISL enables vehicles to establish secure links without pre-coordination:

```
Scenario: Vehicle A encounters unknown friendly Vehicle B

Traditional approach:
  1. A has COMSEC key set X
  2. B has COMSEC key set Y
  3. A and B cannot communicate (no shared keys)
  4. Must route through gateway or wait for key distribution

SISL approach:
  1. A has trust list containing B's public key
  2. B has trust list containing A's public key
  3. A hails B on public channel
  4. Mutual-auth DH establishes secure session
  5. A and B communicate on session-specific spreading code

Time to establish: < 500ms (single round-trip)
Pre-coordination required: Public key exchange only
```

### 3.6 Security Properties Summary

| Property | Mechanism | Operational Benefit |
|----------|-----------|---------------------|
| **Mutual authentication** | DH1 + DH2 terms | Both parties verified |
| **Forward secrecy** | Ephemeral DH3 term | Past sessions protected if key compromised |
| **No key fill** | Asymmetric cryptography | Eliminates SKL logistics |
| **Per-session codes** | HKDF-derived spreading | Each session independently secure |
| **LPI** | Signal below noise floor | Adversary cannot intercept |
| **LPD** | Session code unknown | Adversary cannot detect signal |
| **Replay protection** | Session nonces | Cannot reuse captured traffic |

### 3.7 Cryptographic Standards Compliance

All cryptographic primitives are selected from NSA CNSA 1.0 and NIST FIPS-approved algorithms:

| Function | Algorithm | Standard | Notes |
|----------|-----------|----------|-------|
| **Signatures** | ECDSA with P-384 | FIPS 186-5, CNSA 1.0 | Capability tokens, proofs |
| **Key Agreement** | ECDH with P-384 | SP 800-56A, CNSA 1.0 | Static + ephemeral (3-DH) |
| **Symmetric Encryption** | AES-256-GCM | FIPS 197, SP 800-38D | Session traffic |
| **Key Derivation** | HKDF-SHA384 | SP 800-56C | Session keys from DH |
| **Hashing** | SHA-384 | FIPS 180-4, CNSA 1.0 | Message digests |
| **Random Generation** | DRBG | SP 800-90A | Ephemeral key generation |

**Implementation:** FIPS 140-3 validated cryptographic modules (e.g., OpenSSL FIPS provider, wolfCrypt FIPS, or NSS FIPS) will be used for all cryptographic operations.

**CNSA 2.0 Readiness:** The modular design allows future integration of post-quantum algorithms (CRYSTALS-Kyber for key encapsulation, CRYSTALS-Dilithium for signatures) as NIST PQC standards mature and FIPS validation becomes available.

### 3.8 Integration with GFE Radios

SISL can operate in two modes:

**Mode 1: SISL PHY (full LPI/LPD)**
```
+------------------------------------------------------------------------+
|  SCRAP (authorization)                                                 |
+------------------------------------------------------------------------+
|  SISL (mutual-auth DH + per-session spreading)                         |
+------------------------------------------------------------------------+
|  SDR / SISL-capable radio                                              |
+------------------------------------------------------------------------+

Provides: Full LPI/LPD via session-derived spreading codes
Requires: SDR or SISL-capable radio hardware
```

**Mode 2: SISL over IP (DH key agreement only)**
```
+------------------------------------------------------------------------+
|  SCRAP (authorization)                                                 |
+------------------------------------------------------------------------+
|  SISL session layer (DH + AES-256-GCM)                                 |
+------------------------------------------------------------------------+
|  IP/UDP                                                                |
+------------------------------------------------------------------------+
|  GFE Tactical Radio (Silvus, Persistent, etc.)                         |
+------------------------------------------------------------------------+

Provides: Forward secrecy, no key fill, ad-hoc mesh
Uses: Existing radio's spreading/encryption
```

Mode 2 provides immediate deployment on existing radios while preserving key management benefits.

---

## 4. Trust Establishment

### 4.1 The Problem

SISL requires vehicles to trust each other's public keys. A naive approach--using a shared symmetric key (K_group) to authenticate public key introductions--defeats the purpose: if K_group is compromised, an adversary can impersonate any group member, negating SISL's forward secrecy benefits.

We need a trust model where compromise is bounded, not catastrophic.

### 4.2 Approach: Hierarchical Signing

Trust hierarchy mirrors military command structure:

```
Theater Cmd (root, pre-distributed)
    |
    +-- signs Division Cmd key
            |
            +-- signs Brigade Cmd key
                    |
                    +-- signs Vehicle keys
```

Each commander signs subordinate identity keys. Vehicles verify the signature chain back to a pre-distributed root. Compromise of a commander key affects only their subtree, not the entire force.

Properties:
- Works offline (no CRL/OCSP connectivity required)
- Bounded compromise (proportional to level in hierarchy)
- Matches existing command relationships

### 4.3 Coalition Support

SISL (communication) and SCRAP (command) can use separate trust roots:

- Share SISL roots with coalition partners for telemetry and coordination
- SCRAP authority requires explicit capability token grant
- Partners can communicate with your vehicles but not command them

This enables the DIU requirement for heterogeneous fleet coordination while preserving command authority boundaries.

### 4.4 Deferred to Protocol Specification

Details to be specified in the full SISL/SCRAP protocol specification:
- Certificate format and serialization
- Revocation mechanism
- Validity periods and renewal
- Chain verification algorithm

---

## 5. Resilient Hedged Routing

### 5.1 Concept

C&C computes multiple paths to target; each relay node has pre-authorized fallbacks with cascading timeouts:

```
+------------------------------------------------------------------------+
|                    HEDGED MULTIPATH ROUTING                            |
+------------------------------------------------------------------------+
|                                                                        |
|  C&C has global view: vehicle positions, radio capabilities, topology  |
|                                                                        |
|  C&C computes at send time:                                            |
|    Primary:   A -> B -> C -> Target   (expected RTT: 120ms)            |
|    Fallback1: A -> B -> D -> Target   (expected RTT: 150ms)            |
|    Fallback2: A -> E -> Target        (expected RTT: 100ms)            |
|                                                                        |
|  Each path encrypted separately (relay sees only its next hop)         |
|                                                                        |
|  Relay behavior:                                                       |
|    1. Try primary next hop                                             |
|    2. Wait for ACK (timeout computed from distance + capabilities)     |
|    3. If timeout: try next fallback                                    |
|    4. Repeat until success or all paths exhausted                      |
|                                                                        |
+------------------------------------------------------------------------+
```

### 5.2 Timeout Calculation

Timeouts computed from known parameters:

```python
timeout_ms = (
    propagation_delay(distance_km) +    # ~3.3 us/km
    transmission_time(payload, rate) +   # payload_bits / data_rate
    processing_latency +                 # per-vehicle estimate
    ack_transmission_time +              # minimal ACK
    safety_margin                        # accounts for variability
)
```

### 5.3 Failure Recovery Timeline

```
Scenario: Node B destroyed after command sent

T+0ms:      A sends to B
T+80ms:     A timeout (no ACK from B)
T+81ms:     A tries fallback path via E
T+90ms:     E receives, forwards to Target
T+100ms:    Target receives command
T+150ms:    ACK reaches C&C via return multipath

Total additional delay from node loss: ~70ms
Operator experience: Imperceptible
```

### 5.4 Return Paths: ACKs and Telemetry

Commands include separate multipath for return traffic:

```
Command contains:
  forward_paths: [primary, fallback1, fallback2]
  return_paths:  [return_primary, return_fallback1, return_fallback2]

Target uses return_paths to send back to C&C:
  - Command acknowledgments (immediate)
  - Vehicle status and health (periodic)
  - Sensor data and telemetry (as available)
  - Alert conditions (priority)

Same hedged logic applies to return traffic delivery
```

**Telemetry does not require capability tokens.** Unlike commands (which require authorization), vehicles are inherently permitted to report their state. Return traffic is authenticated by the SISL session - C&C knows which vehicle sent it - but no SCRAP authorization check is needed.

For coalition scenarios where SISL roots are shared but SCRAP authority is not, partner vehicles can still share telemetry and coordinate positions even though they cannot command each other.

---

## 6. Alignment with DIU Requirements

| DIU Requirement | SCRAP Capability | Section |
|-----------------|---------------------|---------|
| Constraint enforcement | Capability token constraints | 2 |
| Intermittent/degraded comms | Hedged routing + SISL | 3, 5 |
| Vehicle-agnostic | Transport-agnostic protocol | 3.1, 3.8 |
| Edge/disconnected | Offline token verification | 2.2 |
| Heterogeneous platforms | Capability registry | 2.1 |
| Command caching | Store-and-forward compatible | 5 |
| Contested environment | LPI/LPD, per-session security | 3.4 |
| Coalition interoperability | Separate SISL/SCRAP trust roots | 4.3 |
| Telemetry sharing | Bidirectional SISL sessions, no auth required | 3.1, 5.4 |

---

## 7. Integration Approach

### 7.1 With LLM Front-End

```python
# Front-end generates structured command
llm_command = intent_parser.parse("Vehicles 1-5 echelon left")
# -> {command: "formation", type: "echelon_left", vehicles: [1,2,3,4,5]}

# SCRAP authorizes and routes
authorized_command = scrap.wrap(
    command=llm_command,
    token=commander_capability_token,
    paths=topology.compute_hedged_paths(target_vehicles)
)

# SISL establishes secure links and delivers
for vehicle in target_vehicles:
    sisl.send(vehicle.pubkey, authorized_command)
```

### 7.2 With Existing C2 Systems

SCRAP exposes REST/gRPC API for integration:

```
+------------------------------------------------------------------------+
|  Existing C2 (GCCS, JADC2, etc.)                                       |
+------------------------------------------------------------------------+
|  SCRAP API                                                             |
|    POST /commands      - Submit command with token                     |
|    GET  /acks/{id}     - Check acknowledgment status                   |
|    GET  /topology      - Current vehicle positions/capabilities        |
|    POST /tokens        - Issue capability tokens                       |
+------------------------------------------------------------------------+
|  SISL + Hedged Routing                                                 |
+------------------------------------------------------------------------+
|  Transport (GFE radios, SATCOM, etc.)                                  |
+------------------------------------------------------------------------+
```

---

## 8. Development Roadmap

### 8.1 Sprint Alignment

| DIU Sprint | Deliverable | Components |
|------------|-------------|------------|
| **Sprint 1** | Core authorization | Capability tokens, single-path routing, GFE IP integration |
| **Sprint 2** | Fleet commands | Formation commands, constraint enforcement, ACK flow |
| **Sprint 3** | Heterogeneous fleet | Capability registry, legacy gateway, multi-radio |
| **Sprint 4** | Resilience | Hedged multipath, SISL session layer |
| **Sprint 5** | Full capability | SISL PHY (if SDR available), production hardening |

### 8.2 Risk Reduction

| Risk | Mitigation |
|------|------------|
| Novel protocol integration | Phased delivery; core authorization first |
| Radio compatibility | Mode 2 (IP overlay) works with any radio |
| Contested RF performance | SISL LPI/LPD validated in Sprint 4-5 |
| LLM hallucination | Capability tokens limit blast radius to granted permissions |

---

## 9. Team and Teaming

### 9.1 DysonLabs Contribution

- SCRAP protocol design and implementation
- SISL protocol design and implementation
- Hedged routing algorithms
- Cryptographic implementation (FIPS 140-3 validated libraries)
- Vehicle-side embedded software

### 9.2 Proposed Teaming

| Role | Partner | Responsibility |
|------|---------|----------------|
| LLM Front-End | [TBD] | Intent parsing, voice/text/GUI |
| Prime Contractor | [TBD - cleared] | FCL, program management |
| Radio Integration | [TBD] | GFE radio testing |

---

## 10. Conclusion

SCRAP and SISL together address the core challenges of commanding autonomous vehicles in contested, communication-denied environments:

- Commands are cryptographically authorized and bounded by capability tokens, preventing unauthorized or out-of-scope actions regardless of how the command originated
- Vehicles can verify authorization offline, without connectivity to ground stations
- Ad-hoc secure links form using only pre-shared public keys, eliminating symmetric key fill logistics
- Per-session spreading codes provide LPI/LPD properties that traditional FHSS cannot match
- Hedged multipath routing recovers from node loss in milliseconds

The result: command authority is cryptographically bounded regardless of source, and communications security improves over current symmetric-key approaches without adding operational burden.

---

## Appendices

### A. Technical Specifications

- SCRAP Protocol Specification
- SISL Protocol Specification
- Hedged Routing Specification

### B. Glossary

| Term | Definition |
|------|------------|
| **Capability Token** | Signed authorization specifying permitted operations |
| **Command Envelope** | Per-command wrapper binding token to specific command via signature |
| **Hedged Routing** | Pre-computed multipath with cascading fallback |
| **LPI/LPD** | Low Probability of Intercept/Detection |
| **Forward Secrecy** | Past sessions protected if long-term key compromised |
| **CNSA** | Commercial National Security Algorithm Suite (NSA) |
| **P-384** | NIST curve secp384r1, CNSA-approved for key agreement and signatures |
| **ECDH** | Elliptic Curve Diffie-Hellman key agreement |
| **ECDSA** | Elliptic Curve Digital Signature Algorithm |
| **HKDF** | HMAC-based Key Derivation Function (RFC 5869) |

---

*Document Version: 1.0 DRAFT*
*Classification: UNCLASSIFIED*
